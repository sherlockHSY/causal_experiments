# -*- coding: utf-8 -*-

"""Generate samples from a latent variable model. 

This module is used to test LiNGAM. 

"""
# Author: Taku Yoshioka, Shohei Shimizu
# License: MIT

import collections
from itertools import chain
import numpy as np
from parse import parse

from bmlingam.utils import dist_names, usr_distrib

float_types = set((float, np.float32, np.float64))
sf_types = set((str, float, np.float32, np.float64))

# Utility function
# rsign: return +1 or -1 at random
# r2intervals: return (-1.5, -0.5) or (0.5, 1.5)
rsign = lambda n, rng: np.sign(rng.randn(n))
r2intervals = lambda n, rng: rsign(n, rng) * (rng.rand(n) + 0.5)

def parse_uniform(s):
    s = s.replace(' ', '')
    p = parse('uniform({},{})', s)

    if p is None:
        return None
    else:
        l = float(p[0])
        u = float(p[1])
        return (l, u)

_dist_name_table = {
    'gmm4_symm_mul': ['m'], # mixture of 4 Gaussians, symmetric and multimodal
    'gmm4_symm_trn': ['n'], # mixture of 4 Gaussians, symmetric and transitional
    'gmm4_symm_uni': ['o'], # mixture of 4 Gaussians, symmetric and unimodal
    'gmm4_asym_mul': ['p'], # mixture of 4 Gaussians, nonsymmetric and multimodal
    'gmm4_asym_trn': ['q'], # mixture of 4 Gaussians, nonsymmetric and transitional
    'gmm4_asym_uni': ['r'], # mixture of 4 Gaussians, nonsymmetric and unimodal
    't5df': ['a'], # Student T with 3 degrees of freedom
    't5df': ['d'], # Student T with 5 degrees of freedom
    'exp': ['e'], # Simple exponential
    'laplace': ['b'], # Double exponential (Laplace)
    'uniform': ['c'], # Uniform
    'dexp2': ['f'], # mixtures of 2 double exponential
    'gmm2_symm_mul': ['g'], # mixture of 2 Gaussians, symmetric and multimodal
    'gmm2_symm_trn': ['h'], # mixture of 2 Gaussians, symmetric and transitional
    'gmm2_symm_uni': ['i'], # mixture of 2 Gaussians, symmetric and unimodal
    'gmm2_asym_mul': ['j'], # mixture of 2 Gaussians, nonsymmetric and multimodal
    'gmm2_asym_trn': ['k'], # mixture of 2 Gaussians, nonsymmetric and transitional
    'gmm2_asym_uni': ['l'], # mixture of 2 Gaussians, nonsymmetric and unimodal
    'gauss': ['s'], # Gaussian distribution
    'all': dist_names
}

class GenDataParams(object):
    """Parameters for generating artificial data. 

    This parameter object is an argument of function :code:`gen_artificial_data()`. 
    The number of samples in the data is specified with a parameter. 

    :param int n_samples: Number of samples in the data.

    The data generated by this function has two random variables 
    :math:`x_{1}^{(i)}` and :math:`x_{2}^{(i)}`, where :math:`i` denotes the 
    sample index. The generative model of data is given as follows: 

    .. math::

        x_{1}^{(i)} &= \mu_{1} + s_{1}\sum_{q=1}^{Q}\lambda_{1}^{q}f_{q}^{(i)} + e_{1}^{(i)} \\\\
        x_{2}^{(i)} &= \mu_{2} + s_{2}\sum_{q=1}^{Q}\lambda_{2}^{q}f_{q}^{(i)} + b_{21}x_{1}^{(i)} + e_{2}^{(i)}. 

    All of the above quantities in the RHS are random variables. This equation 
    corresponds to causal direction from :math:`x_{1}` to :math:`x_{2}`. The 
    function randomly flips the causality with 50\% probability, i.e., 
    :math:`x_{2}` to :math:`x_{1}`. For testing purpose, however, one might want 
    to fix causal direction. The randomness could be controlled by parameter 
    :code:`fix_causality`. 

    :param bool fix_causality: Randomness of causal direction. If this 
                               parameter is set to :code:`True`, the causal 
                               direction of the generative model is determined 
                               with 50\% probability. Otherwise, the causal 
                               direction isfixed to :math:`x_{1}` to :math:`x_{2}`. 
                               Default is :code:`False`. 

    :math:`b_{21}` is the regression coefficient, corresponding to strength of 
    the causal effect. :math:`\mu_{r} (r=1,2)` is the bias term. These random 
    variables are drawn only once for a dataset. Probability distributions for 
    these random variables are specified with the following parameters. 

    :type b21_dist: str or float
    :param b21_dist: Distribution of :math:`b_{21}`. If :code:`b21_dist` is 
                     :code:`'r2interval'`, :math:`b21` is drawn from a mixture 
                     of two uniform distributions :math:`[-1.5, -0.5]` and 
                     :math:`[0.5, 1.5]`, as appeared in the paper. If a float 
                     value is given, :math:`b_{21}` is set to that value. 
    :type mu1_dist: str or float
    :param mu1_dist: Distribution of :math:`\mu_{1}`. If :code:`randn`, 
                     :math:`mu_{1}` is drawn from the standard normal 
                     distribution. If a float value is given, :math:`\mu_{1}` 
                     is set to that value. 
    :type mu2_dist: str or float
    :param mu2_dist: Same with :code:`mu1_dist`. 

    :math:`s_{r}\sum_{q=1}^{Q}\lambda_{r,q}f_{q}^{(i)} (r=1,2)` is a 
    weighted sum of confounders. :math:`s_{r}` is just a scaling constant. 
    The weights :math:`\lambda_{r,q}` (:math:`q=1,\cdots, Q`) are dependent on 
    confounders and could be random variables or constants. Random variables 
    :math:`f_{q}^{(i)}` are dependent on both of confounders and samples. 
    The parameters related to the confounders are as below. 

    :type f1_scale: float
    :param f1_scale: Scaling constant for the confound term in :code:`x_{1}`. 
                     :code:`f1_coef=[1, 1, 1], f1_scale=1/3.0` is equivalent to
                     :code:`f1_coef=[1/3.0, 1/3.0, 1/3.0], f1_scale=1`. 
    :type f1_coef: list of (str or float)
    :param f1_coef: List of distributions or constants of weights of 
                    confounders. The length of the list is the number of 
                    confounders in the weighted sum. If :code:`f1_coef[q]` is 
                    :code:`r2intervals`, the uniform mixture distribution, 
                    used for :math:`b_{21}`, is also used to draw a value of 
                    the :math:`q`-th weight. If a float value is given, the 
                    weight is set to that value. 
    :type conf_dist: list of (list of strs)
    :param conf_dist: List of possible distributions for confound factors. 
                      The length of the list, :code:`len(conf_dist)`, is equal 
                      to the number of confounders. For example, if 
                      :code:`conf_dist = [['laplace'], ['exp', 'uniform`]]`, 
                      the 1st confounder is distributed according to the 
                      standard Laplace distribution and the 2nd confounder is 
                      drawn from either the exponential or uniform distributions 
                      with 50\% probability. :code:`'all'` denotes that all 
                      distributions in :code:`usr_distrib()` are possible. 
    :type f2_scale: float
    :param f2_scale: Same with :code:`f1_scale`. 
    :type f2_coef: list of (str or float)
    :param f2_coef: Same with :code:`f1_coef`.

    :math:`e_{r}^{(i)}` is a noise term. Its distribution and standard 
    deviation are specified by the following parameters. 

    :type e1_dist: List of strs
    :param e1_dist: Possible distributions of noise. 
    :type e1_std: float
    :param e1_std: Standard deviation of the noise. 
    :type e2_dist: List of strs
    :param e2_dist: Same with :code:`e1_dist`. 
    :type e2_std: float
    :param e2_std: Same with :code:`e1_std`. 

    The seed of random number generator needs to be set. 

    :param seed: Seed of random number generator.

    Here is the list of distributions in :code:`usr_distrib()`. 

    - 'gmm4_symm_mul': mixture of 4 Gaussians, symmetric and multimodal
    - 'gmm4_symm_trn': mixture of 4 Gaussians, symmetric and transitional
    - 'gmm4_symm_uni': mixture of 4 Gaussians, symmetric and unimodal
    - 'gmm4_asym_mul': mixture of 4 Gaussians, nonsymmetric and multimodal
    - 'gmm4_asym_trn': mixture of 4 Gaussians, nonsymmetric and transitional
    - 'gmm4_asym_uni': mixture of 4 Gaussians, nonsymmetric and unimodal
    - 't5df': Student T with 3 degrees of freedom
    - 't5df': Student T with 5 degrees of freedom
    - 'exp': Simple exponential
    - 'laplace': Double exponential (Laplace)
    - 'uniform': Uniform
    - 'dexp2': mixtures of 2 double exponential
    - 'gmm2_symm_mul': mixture of 2 Gaussians, symmetric and multimodal
    - 'gmm2_symm_trn': mixture of 2 Gaussians, symmetric and transitional
    - 'gmm2_symm_uni': mixture of 2 Gaussians, symmetric and unimodal
    - 'gmm2_asym_mul': mixture of 2 Gaussians, nonsymmetric and multimodal
    - 'gmm2_asym_trn': mixture of 2 Gaussians, nonsymmetric and transitional
    - 'gmm2_asym_uni': mixture of 2 Gaussians, nonsymmetric and unimodal
    - 'all': All distributions above
    """
    def __init__(
        self, 
        n_samples=100,
        b21_dist='r2intervals', 
        mu1_dist=5.0, 
        mu2_dist=10.0, 
        f1_scale=1.0, 
        f2_scale=1.0, 
        f1_coef=['r2intervals', 'r2intervals', 'r2intervals'], 
        f2_coef=['r2intervals', 'r2intervals', 'r2intervals'], 
        conf_dist=[['all'], ['all'], ['all']], 
        e1_std=3.0, 
        e2_std=3.0, 
        e1_dist=['laplace'], 
        e2_dist=['laplace'], 
        fix_causality=False, 
        seed=0):

        self._n_samples = n_samples
        self._b21_dist = b21_dist
        self._mu1_dist = mu1_dist
        self._mu2_dist = mu2_dist
        self._f1_scale = f1_scale
        self._f2_scale = f2_scale
        self._f1_coef = f1_coef
        self._f2_coef = f2_coef
        self._conf_dist = conf_dist
        self._e1_std = e1_std
        self._e2_std = e2_std
        self._e1_dist = e1_dist
        self._e2_dist = e2_dist
        self._fix_causality = fix_causality
        self._seed = seed

        # Check the number of confounders
        assert(len(conf_dist) == len(f1_coef))
        assert(len(conf_dist) == len(f2_coef))

        assert(type(conf_dist) is list)
        assert(all([type(d) is list for d in conf_dist]))

    @property
    def n_samples(self):
        return self._n_samples

    @n_samples.setter
    def n_samples(self, value):
        self._n_samples = value

    @property
    def b21_dist(self):
        return self._b21_dist

    @b21_dist.setter
    def b21_dist(self, value):
        self._b21_dist = value

    @property
    def mu1_dist(self):
        return self._mu1_dist

    @mu1_dist.setter
    def mu1_dist(self, value):
        self._mu1_dist = value

    @property
    def mu2_dist(self):
        return self._mu2_dist

    @mu2_dist.setter
    def mu2_dist(self, value):
        self._mu2_dist = value

    @property
    def f1_scale(self):
        return self._f1_scale

    @f1_scale.setter
    def f1_scale(self, value):
        self._f1_scale = value

    @property
    def f2_scale(self):
        return self._f2_scale

    @f2_scale.setter
    def f2_scale(self, value):
        self._f2_scale = value

    @property
    def f1_coef(self):
        return self._f1_coef

    @f1_coef.setter
    def f1_coef(self, value):
        self._f1_coef = value

    @property
    def f2_coef(self):
        return self._f2_coef

    @f2_coef.setter
    def f2_coef(self, value):
        self._f2_coef = value

    @property
    def conf_dist(self):
        return self._conf_dist

    @conf_dist.setter
    def conf_dist(self, value):
        self._conf_dist = value

    @property
    def e1_std(self):
        return self._e1_std

    @e1_std.setter
    def e1_std(self, value):
        self._e1_std = value

    @property
    def e2_std(self):
        return self._e2_std

    @e2_std.setter
    def e2_std(self, value):
        self._e2_std = value

    @property
    def e1_dist(self):
        return self._e1_dist

    @e1_dist.setter
    def e1_dist(self, value):
        self._e1_dist = value

    @property
    def e2_dist(self):
        return self._e2_dist

    @e2_dist.setter
    def e2_dist(self, value):
        self._e2_dist = value

    @property
    def fix_causality(self):
        return self._fix_causality

    @fix_causality.setter
    def fix_causality(self, value):
        self._fix_causality = value

    @property
    def seed(self):
        return self._seed

    @seed.setter
    def seed(self, value):
        self._seed = value

def _gen_usr_distrib(size, dists, rng):
    """Generate random samples from usr_distrib.
    """
    flt = lambda l: list(chain.from_iterable(l))
    dist_names_local = flt([_dist_name_table[k] for k in dists])

    # Check size
    if isinstance(size, collections.Iterable):
        n_samples, n_dim = (size[0], 1) if len(size) == 1 else size
    else:
        n_samples, n_dim = (size, 1)

    # Select distributions
    ixs_dist = rng.randint(0, len(dist_names_local), n_dim)
    dists = [dist_names_local[ix_dist] for ix_dist in ixs_dist]

    # Generate samples and normalize
    xs_ = np.vstack(
        [usr_distrib(dist, 'rnd', n_samples, rng) for dist in dists]).T
    xs = (xs_ - np.mean(xs_, axis=0)) / np.std(xs_, axis=0)

    return xs

def _gen_reg_coef(gen_data_params, rng):
    b21_dist = gen_data_params.b21_dist
    p_uniform = parse_uniform(b21_dist)

    if b21_dist == 'r2intervals':
        b21 = r2intervals(1, rng)[0]

    elif p_uniform is not None:
        l = p_uniform[0]
        u = p_uniform[1]
        assert(l < u)
        b21 = rng.uniform(low=l, high=u, size=1)[0]

    elif type(b21_dist) in float_types:
        b21 = float(b21_dist)

    else:
        raise ValueError("Invalid value of b21_dist: %s" % b21_dist)

    return b21

def _gen_biases(gen_data_params, rng):
    mu1_dist = gen_data_params.mu1_dist
    mu2_dist = gen_data_params.mu2_dist

    if mu1_dist == 'randn':
        mu1 = rng.randn(1)
    elif type(mu1_dist) in float_types:
        mu1 = mu1_dist
    else:
        raise ValueError("Invalid value of mu1_dist: %s" % str(mu1_dist)) 

    if mu2_dist == 'randn':
        mu2 = rng.randn(1)
    elif type(mu2_dist) in float_types:
        mu2 = mu2_dist
    else:
        raise ValueError("Invalid value of mu2_dist: %s" % str(mu2_dist)) 

    mus = np.array([mu1, mu2]).reshape(-1)

    return mus

def _gen_conf_factors(gen_data_params, rng):
    conf_dist = gen_data_params.conf_dist
    n_samples = gen_data_params.n_samples

    fs = np.vstack(
        [_gen_usr_distrib(n_samples, ds, rng).ravel() for ds in conf_dist]
    )

    return fs.T # shape=(n_samples, n_confounders)

def _gen_weights(gen_data_params, rng):
    f1_coef = gen_data_params.f1_coef
    f2_coef = gen_data_params.f2_coef
    f1_scale = gen_data_params.f1_scale
    f2_scale = gen_data_params.f2_scale

    def _sample_coef(d):
        if d == 'r2intervals':
            return r2intervals(1, rng)[0]
        elif type(d) in float_types:
            return float(d)
        else:
            raise ValueError("Invalid value of f[1/2]_coef: %s" % d)

    l1s = f1_scale * np.array([_sample_coef(d) for d in f1_coef])
    l2s = f2_scale * np.array([_sample_coef(d) for d in f2_coef])
    ls = np.vstack((l1s, l2s))

    return ls

def _gen_errors(gen_data_params, rng):
    n_samples = gen_data_params.n_samples
    e1_std = gen_data_params.e1_std
    e2_std = gen_data_params.e2_std
    e1_dist = gen_data_params.e1_dist
    e2_dist = gen_data_params.e2_dist

    if e1_std == 'r2intervals':
        be1 = np.abs(r2intervals(1, rng)[0])
    elif type(e1_std) in float_types:
        be1 = float(e1_std)
    else:
        raise ValueError("Invalid value of e1_std: %s" % str(e1_std))

    if e2_std == 'r2intervals':
        be2 = np.abs(r2intervals(1, rng)[0])
    elif type(e2_std) in float_types:
        be2 = float(e2_std)
    else:
        raise ValueError("Invalid value of e2_std: %s" % str(e2_std))

    e1s = _gen_usr_distrib(n_samples, e1_dist, rng).ravel() * be1
    e2s = _gen_usr_distrib(n_samples, e2_dist, rng).ravel() * be2
    es = np.vstack((e1s, e2s)).T

    return es

def _gen_artificial_data_main(gen_data_params, rng):
    n_samples = gen_data_params.n_samples
    n_confounders = len(gen_data_params.conf_dist)

    b21 = _gen_reg_coef(gen_data_params, rng)
    mus = _gen_biases(gen_data_params, rng)
    ls = _gen_weights(gen_data_params, rng)
    es = _gen_errors(gen_data_params, rng)

    assert(type(b21) in float_types)
    assert(mus.shape == (2,))
    assert(ls.shape == (2, n_confounders))
    assert(es.shape == (n_samples, 2))

    if len(gen_data_params.conf_dist) == 0:
        confs = np.zeros((n_samples, 2))
    else:
        fs = _gen_conf_factors(gen_data_params, rng)
        assert(fs.shape == (n_samples, n_confounders))
        confs = fs.dot(ls.T)
        assert(confs.shape == (n_samples, 2))

    x1s = mus[0] + confs[:, 0] + es[:, 0]
    x2s = mus[1] + b21 * x1s + confs[:, 1] + es[:, 1]

    return {
        'xs': np.vstack((x1s, x2s)).T,  # shape=(n_samples, 2)
        'b': b21, 
        'es': es, 
        'confs': confs
    }

def gen_artificial_data(gen_data_params):
    rng = np.random.RandomState(gen_data_params.seed)

    data = _gen_artificial_data_main(gen_data_params, rng)
    xs = data['xs']
    es = data['es']

    if (not gen_data_params.fix_causality) and rng.randn(1) < 0:
        data = { # x2 -> x1
            'xs': np.vstack((xs[:, 1], xs[:, 0])).T, 
            'causality_true': [2, 1], 
            'b': data['b'], 
            'es': np.vstack((es[:, 1], es[:, 0])).T, 
            'confs': data['confs']
        }
    else:
        data = { # x1 -> x2
            'xs': xs, 
            'causality_true': [1, 2], 
            'b': data['b'], 
            'es': es, 
            'confs': data['confs']
        }

    return data
